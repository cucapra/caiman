
timeline time(e: event): event { returns e. }
spatial space(bs: bufferspace): bufferspace { returns bs. }

// implicit here:
// feq main {main}
// feq rec_sum {rec_sum}

val main() : i64 {
    returns rec_sum(10).
}

fn foo() : i64 
    impls main, time, space
{
    let x = 10;
    return head(x);
}

val rec_sum(a: i64) : i64 {
    rec :- a + rec_sum(a - 1).
    b :- rec if a > 0 else 0.
    returns b.
}

// full specification
// a: i64<input(a):usable, none(e):usable, none(bs):usable> in order value, timeline, spatial
// ? can be used to infer part or all of the tag

// ex. `a: i64<?>` is the same as `a: i64`, which is the same as 
// `a: i64<?, ?, ?>`

// specify only quotients:
// `a: i64<input():_, none():_, none():_>`

// specify only flows:
// `a: i64<?():usable, ?():usable, ?():usable>`


fn head(a: i64 @ [input(rec_sum.a)-usable, none(time.e)-usable, none(space.e)-usable]) : i64 
    impls rec_sum, time, space
{
    if a > 0 {
        // it seems reasonable that these implicit operations would be
        // peformed on the host
        return a + head(a - 1);
    } else {
        return 0;
    }
}

pipeline main { foo }