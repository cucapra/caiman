use crate::convert::Convert;
use crate::ir;
use std::collections::{HashMap, HashSet};
use std::mem::replace;
use thiserror::Error;

mod from_ir;
mod into_ir;

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct NodeIndex(usize);

// Pulls in Operation enum & inherent methods
include!(concat!(env!("OUT_DIR"), "/generated/dataflow_base.rs"));

// TODO: This may be autogenerated in the future
enum Tail {
    Return {
        return_values: Box<[NodeIndex]>,
    },
    Yield {
        funclet_ids: Box<[ir::FuncletId]>,
        captured_arguments: Box<[NodeIndex]>,
        return_values: Box<[NodeIndex]>,
    },
}
impl Tail {
    fn for_each_dependency(&self, mut f: impl FnMut(&NodeIndex)) {
        match self {
            Self::Return { return_values } => return_values.iter().for_each(&mut f),
            Self::Yield {
                captured_arguments,
                return_values,
                ..
            } => {
                captured_arguments.iter().for_each(&mut f);
                return_values.iter().for_each(&mut f);
            }
        }
    }
}

pub trait TreeTransformer {
    fn apply(&mut self, graph: &mut Graph, index: NodeIndex);
}

#[derive(Debug, Error)]
pub enum Error {
    #[error("failed to translate IR to dataflow graph")]
    FromIr(#[from] from_ir::Error),
}

enum Node {
    /// A node containing an operation.
    Operation(Operation),

    /// A reference to another node. When operating on a reference node, you traverse the
    /// "linked list" of references until a Node::Operation is found and operate on that instead.
    ///
    /// # Why references?
    ///
    /// Suppose you have identical nodes A and B. You'll want to merge A and B into a single node.
    /// Normally, this would mean taking all incoming edges for A and B and assigning them to the
    /// merged node. For complex technical reasons, [`Graph`] doesn't keep track of incoming edges,
    /// so iterating over incoming edges would be very expensive.
    ///
    /// We can make B into a reference to A instead. That way we don't need to modify any of the
    /// nodes which depend on B.
    Reference(NodeIndex),
}

pub struct Graph {
    nodes: Vec<Node>,
    tail: Tail,
}
impl Graph {
    pub fn from_ir(ir_nodes: &[ir::Node], ir_tail: &ir::TailEdge) -> Result<Self, Error> {
        let mut nodes = Vec::with_capacity(ir_nodes.len());
        for (i, ir_node) in ir_nodes.iter().enumerate() {
            let context = from_ir::Context::new(i);
            let operation = ir_node.convert(&context)?;
            nodes.push(Node::Operation(operation));
        }
        let tail = {
            let context = from_ir::Context::new(nodes.len());
            ir_tail.convert(&context)?
        };
        Ok(Self { nodes, tail })
    }
    /// Returns the index of the node containing the operation referenced by `index`.
    /// (This may be the same as `index`.) It's guaranteed that the node at the resulting index
    /// will be a [`Node::Operation`].
    fn resolve_index(&self, mut index: NodeIndex) -> NodeIndex {
        loop {
            // I'm pretty sure reference cycles are impossible if you only use the `pub` functions
            // Worst case scenario, they're not & we get an infinite loop (easy to debug)
            match &self.nodes[index.0] {
                Node::Operation(_) => return index,
                Node::Reference(next) => index = *next,
            }
        }
    }
    /// Retrieves a reference to the operation associated with `index`.
    pub fn operation(&self, index: NodeIndex) -> &Operation {
        let real_index = self.resolve_index(index);
        match &self.nodes[real_index.0] {
            Node::Operation(operation) => operation,
            Node::Reference(_) => unreachable!(),
        }
    }
    /// Retrieves a mutable reference to the operation associated with `index`.
    pub fn operation_mut(&mut self, index: NodeIndex) -> &mut Operation {
        let real_index = self.resolve_index(index);
        match &mut self.nodes[real_index.0] {
            Node::Operation(operation) => operation,
            Node::Reference(_) => unreachable!(),
        }
    }
    /// Makes the node at `src` into a reference to `dst`. Note that there is no way to convert
    /// a node from a reference back into an operation -- this is to make it easier to reason
    /// about correctness.
    pub fn make_reference(&mut self, src: NodeIndex, dst: NodeIndex) {
        let real_src = self.resolve_index(src);
        // strictly speaking, we don't need to resolve dst, but it might help performance
        let real_dst = self.resolve_index(dst);
        self.nodes[real_src.0] = Node::Reference(real_dst);
    }
    pub fn apply_transforms(&mut self, transforms: &mut [&mut dyn TreeTransformer]) {
        let mut dfs = Dfs::new(self);
        while let Some(event) = dfs.next(self) {
            if let DfsEvent::Leave(index) = event {
                for transform in transforms.iter_mut() {
                    transform.apply(self, index);
                }
            }
        }
    }
    pub fn into_ir(&self) -> (Vec<ir::Node>, ir::TailEdge) {
        let mut dfs = Dfs::new(&self);
        let mut ir_nodes = Vec::new();
        let mut node_map = HashMap::new();
        while let Some(event) = dfs.next(self) {
            // technically we should do cycle detection here
            if let DfsEvent::Leave(index) = event {
                let context = into_ir::Context::new(&node_map);
                ir_nodes.push(self.operation(index).convert(&context).unwrap());
                node_map.insert(index, node_map.len());
            }
        }
        let ir_tail = {
            let context = into_ir::Context::new(&node_map);
            (&self.tail).convert(&context).unwrap()
        };
        (ir_nodes, ir_tail)
    }
}

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub enum DfsEvent {
    Visit(NodeIndex),
    Leave(NodeIndex),
}
pub struct Dfs {
    stack: Vec<DfsEvent>,
    visited: HashSet<NodeIndex>,
}
impl Dfs {
    fn new(graph: &Graph) -> Self {
        let visited = HashSet::with_capacity(graph.nodes.len());
        let mut stack = Vec::new();
        graph.tail.for_each_dependency(|&i| {
            stack.push(DfsEvent::Visit(i)) //
        });
        Self { stack, visited }
    }
    fn next(&mut self, graph: &Graph) -> Option<DfsEvent> {
        loop {
            let index = match self.stack.pop() {
                Some(DfsEvent::Visit(index)) => index,
                other => return other,
            };
            if self.visited.insert(index) {
                graph.operation(index).for_each_dependency(|&i| {
                    self.stack.push(DfsEvent::Visit(i)) //
                });
                return Some(DfsEvent::Visit(index));
            }
        }
    }
}
