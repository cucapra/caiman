use super::{NodeIndex, Operation, Tail};
use crate::convert::{ConversionContext, Convert};
use crate::ir;
use std::collections::HashMap;
use std::convert::Infallible;

/// Context used for dataflow-to-IR conversions.
pub struct Context {
    /// There are three logical states for a NodeIndex:
    ///     - It isn't (yet) included in the IR. It will not be in `node_map`.
    ///     - It's being added to the IR. It will be mapped to `None` in `node_map`.
    ///     - It's been mapped to id `id` in the IR. It will be mapped to `Some(ir)` in `node_map`.
    node_map: HashMap<NodeIndex, Option<ir::NodeId>>,
}
impl Context {
    pub fn new() -> Self {
        Self {
            node_map: HashMap::new(),
        }
    }
    pub fn id_for_index(&self, index: NodeIndex) -> Result<ir::NodeId, Infallible> {
        Ok(self.node_map[&index].expect("logic error: node not yet added to IR"))
    }
    pub fn begin_visit(&mut self, index: NodeIndex) {
        // Any graph cycle is due to a bug, so there's no point in handling them gracefully.
        // Instead we should just fix the bug
        let old = self.node_map.insert(index, None);
        assert!(old == None, "logic error: graph cycle")
    }
    pub fn finish_visit(&mut self, index: NodeIndex, node_id: ir::NodeId) {
        let old = self.node_map.insert(index, Some(node_id));
        assert!(old == Some(None), "logic error: graph cycle")
    }
    pub fn is_fully_visited(&self, index: NodeIndex) -> bool {
        self.node_map.get(&index).copied().flatten().is_none()
    }
}
impl ConversionContext for Context {
    type Error = Infallible;
}

impl Convert<ir::NodeId, Context> for NodeIndex {
    fn convert(self, context: &Context) -> Result<ir::NodeId, Infallible> {
        context.id_for_index(self)
    }
}
impl Convert<Box<[ir::NodeId]>, Context> for Box<[NodeIndex]> {
    fn convert(self, context: &Context) -> Result<Box<[ir::NodeId]>, Infallible> {
        self.iter().map(|&id| id.convert(context)).collect()
    }
}
impl Convert<ir::Node, Context> for Operation {
    fn convert(self, context: &Context) -> Result<ir::Node, Infallible> {
        include!(concat!(env!("OUT_DIR"), "/generated/dataflow_to_ir.txt"))
    }
}
// TODO: This may be autogenerated in the future
impl Convert<ir::TailEdge, Context> for Tail {
    fn convert(self, context: &Context) -> Result<ir::TailEdge, Infallible> {
        Ok(match self {
            Tail::Return { return_values } => ir::TailEdge::Return {
                return_values: return_values.convert(context)?,
            },
            Tail::Yield {
                funclet_ids,
                captured_arguments,
                return_values,
            } => ir::TailEdge::Yield {
                funclet_ids: funclet_ids.convert(context)?,
                captured_arguments: captured_arguments.convert(context)?,
                return_values: return_values.convert(context)?,
            },
        })
    }
}
