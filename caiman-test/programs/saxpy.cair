version 0.0.1
types [
    f32,
    u64,
    array<f32, 256>,
    slot $arr {
        type: f32,
        stage: ready,
        place : local,
    },
    event $event0 {
        place : local
    },
]

// This is pretty non-optimal since it's potentially two seperate kernel dispatches,
// not to mention that it operates on a scalar...
// It only exists for learning the syntax
value @saxpy(%a : f32, %x : f32, %y : f32) -> f32 {
    %ax_t = call @fmul(%a, %x);
    %ax = extract %ax_t 0;
    %z_t = call @fadd(%ax, %y);
    %z = extract %z_t 0;
    return %z;
}

// An "extreme"-ly unoptimized version of saxpy that does as much as possible in the value funclet.
// This mostly exists to test optimizations such as kernel fusion.
// Without optimizations, this is the worst code you could ever write, probably.
// NOTE REMOVE: The condition for a scheduling select is a slot, not a join. It's bugged rn though
value @saxpy_extreme_rec_val(
    %a : array<f32, 256>, 
    %x : array<f32, 256>, 
    %y : array<f32, 256>, 
    %i : u64, 
    %working : array<f32, 256>
) -> array<f32, 256> {
    %len = constant-unsigned 256u64;
    // TODO: Is it just me, or is it kind of weird to specify the location (via external) in the
    // value language in the first place? It kind of seems like a leaky abstraction. Obviously you
    // will want to implement certain things in one place only, but I feel like saying "hey this
    // is GPU stuff" belongs in the scheduling language
    %stop_t = call @cmp_lt(%i, %len);
    %stop = extract %stop_t 0;
    
    %av_t = call @array_get(%a, %i);
    %av = extract %av_t 0;

    %xv_t = call @array_get(%x, %i);
    %xv = extract %xv_t 0;

    %axv_t = call @fmul(%av_t, %xv_t);
    %axv = extract %axv_t 0;

    %yv_t = call @array_get(%y, %i);
    %yv = extract %yv_t 0;

    %axyv_t = call @fadd(%axv_t, %yv_t);
    %axyv = extract %axyv_t 0;

    %workingMut_t = call @array_put(%working, %i);
    %workingMut = extract %workingMut_t 0;

    %one = constant-unsigned 1u64;
    %i2_t = call @uadd(%i, %one);
    %i2 = extract %i2_t 0;

    %recursed_t = call @saxpy_extreme_rec(%a, %x, %y, %i2, %workingMut);
    %recursed = extract %recursed_t 0;

    // In value language infinite recursion is actually fine
    // You break recursion via scheduling
    %final_t = select %stop %working %recursed;
    %final = extract %final 0;

    return %final;
}

// TODO: A bit confused about extract value, what's the point again?
// TODO: Remove the boilerplate.
external_cpu @fmul_cpu(f32, f32) -> f32;
external_gpu @fmul_gpu(%a : f32, %b : f32) -> [%c : f32] : "caiman-test/programs/saxpy/fmul.wgsl"
{
    resource {group : 0, binding : 0, input : %a},
    resource {group : 0, binding : 1, input : %b},
    resource {group : 0, binding : 2, output : %c}
}
value @fmul_cpu_val(%a: f32, %b: f32) -> f32 {
    %result_t = call @fmul_cpu(%a, %b);
    %result = extract %result_t 0;
    return %result;
}
value @fmul_gpu_val(%a: f32, %b: f32) -> f32 {
    %result_t = call @fmul_gpu(%a, %b);
    %result = extract %result_t 0;
    return %result;
}

external_cpu @uadd_cpu(u64, u64) -> u64;
external_gpu @uadd_gpu(%a : u64, %b : u64) -> [%c: u64]: "caiman-test/programs/saxpy/uadd.wgsl"
{
    resource {group : 0, binding : 0, input : %a},
    resource {group : 0, binding : 1, input : %b},
    resource {group : 0, binding : 2, output : %c}
}

value @uadd_cpu_val(%a: u64, %b: u64) -> u64 {
    %result_t = call @uadd_cpu(%a, %b);
    %result = extract %result_t 0;
    return %result;
}
value @uadd_gpu_val(%a: u64, %b: u64) -> u64 {
    %result_t = call @uadd_gpu(%a, %b);
    %result = extract %result_t 0;
    return %result;
}

external_cpu @fadd_cpu(f32, f32) -> f32;
external_gpu @fadd_gpu(%a : f32, %b : f32) -> [%c: f32]: "caiman-test/programs/saxpy/fadd.wgsl"
{
    resource {group : 0, binding : 0, input : %a},
    resource {group : 0, binding : 1, input : %b},
    resource {group : 0, binding : 2, output : %c}
}

value @fadd_cpu_val(%a: f32, %b: f32) -> f32 {
    %result_t = call @fadd_cpu(%a, %b);
    %result = extract %result_t 0;
    return %result;
}
value @fadd_gpu_val(%a: f32, %b: f32) -> f32 {
    %result_t = call @fadd_gpu(%a, %b);
    %result = extract %result_t 0;
    return %result;
}

external_cpu @cmp_lt_cpu(u64, u64) -> u64;
external_gpu @cmp_lt_gpu(%a : u64, %b : u64) -> [%c: u64]: "caiman-test/programs/saxpy/cmp_lt.wgsl"
{
    // Would be cool to identify optimizations here.
    // These could *trivially* be combined into a single binding with two fields,
    // at least by a human programmer, but will that semantically work with Caiman?
    resource {group : 0, binding : 0, input : %a},
    resource {group : 0, binding : 1, input : %b},
    resource {group : 0, binding : 2, output : %c}
}
value @cmp_lt_cpu_val(%a: u64, %b: u64) -> u64 {
    %result_t = call @cmp_lt_cpu(%a, %b);
    %result = extract %result_t 0;
    return %result;
}
value @cmp_lt_gpu_val(%a: u64, %b: u64) -> u64 {
    %result_t = call @cmp_lt_gpu(%a, %b);
    %result = extract %result_t 0;
    return %result;
}

external_cpu @array_get_cpu(array<f32,256>, u64) -> f32;
external_gpu @array_get_gpu(%a : array<f32,256>, %i : u64) -> [%v: f32] : "caiman-test/programs/saxpy/array_get.wgsl" 
{
    resource {group : 0, binding : 0, input: %a},
    resource {group : 0, binding : 1, input: %i},
    resource {group : 0, binding : 2, output: %v} 
}
value @array_get_cpu_val(%a: array<f32,256>, %i: u64) -> f32 {
    %result_t = call @array_get_cpu(%a, %i);
    %result = extract %result_t 0;
    return %result;
}
value @array_get_gpu_val(%a: array<f32,256>, %i: u64) -> f32 {
    %result_t = call @array_get_gpu(%a, %i);
    %result = extract %result_t 0;
    return %result;
}

external_cpu @array_put_cpu(array<f32, 256>, u64, f32) -> array<f32, 256>;
external_gpu @array_put_gpu(%a : array<f32, 256>, %i : u64, %v : f32) -> [%mutated: array<f32, 256>] : "caiman-test/programs/saxpy/array_put.wgsl" 
{
    resource {group : 0, binding : 0, input: %a},
    resource {group : 0, binding : 1, input: %i},
    resource {group : 0, binding : 2, input: %v},
    resource {group : 0, binding : 3, output: %mutated} // TODO: Would be nice to alias this with group 0 binding 0
}
value @array_put_cpu_val(%a: array<f32,256>, %i: u64, %v: f32) -> array<f32, 256> {
    %result_t = call @array_put_cpu(%a, %i, %v);
    %result = extract %result_t 0;
    return %result;
}
value @array_put_gpu_val(%a: array<f32,256>, %i: u64, %v: f32) -> array<f32, 256> {
    %result_t = call @array_put_gpu(%a, %i, %v);
    %result = extract %result_t 0;
    return %result;
}

// Surprising: 'Non-local funclet used for value function add_cpu', src\assembly\ast_to_ir.rs:732:18
// I thought the intended use of value functions was to select between different implementations,
// and one of the factors was whether they ran on the CPU or the GPU?
// RESOLVED: This *should* be allowed but it's not implemented yet.
value_function @uadd(u64, u64) -> u64: [@uadd_cpu_val, @uadd_gpu_val];
value_function @fadd(f32, f32) -> f32: [@fadd_cpu_val, @fadd_gpu_val];
value_function @fmul(f32, f32) -> f32: [@fmul_cpu_val, @fmul_gpu_val];
value_function @cmp_lt(u64, u64) -> u64: [@cmp_lt_cpu_val, @cmp_lt_gpu_val];
value_function @array_get(array<f32, 256>, u64) -> f32: [@array_get_cpu_val, @array_get_gpu_val];
value_function @array_put(array<f32, 256>, u64, f32) -> array<f32, 256>: [@array_put_cpu_val, @array_put_gpu_val];
value_function @saxpy_extreme_rec(array<f32, 256>, 
    array<f32, 256>, 
    array<f32, 256>, 
    u64, 
    array<f32, 256>
) -> array<f32, 256>: [@saxpy_extreme_rec_val];

extras {}

pipeline "pipeline_saxpy" = @saxpy;