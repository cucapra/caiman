version 0.0.2

// is meant to parse, not to compile/run
// just a reference/test for syntax parsing
// the complete set of nodes parsable and all that

type f32;
type f64;
type u8;
type u16;
type u32;
type u64;
type usize;
type i8;
type i16;
type i32;
type i64;
type array<i32, 2>;
type erased_length_array<u32>;
type tuple<f32, u8>;
type const_ref<u64>;
type mut_ref<const_ref<u64>>;
type const_slice<array<i32, 2>>;
type mut_slice<i32>;
type gpu_buffer_ref<i32>;
type gpu_buffer_slice<i32>;
type gpu_buffer_allocator;
type cpu_buffer_allocator;
type cpu_buffer_ref<i64>;

native_value %native_i64 : i64;
slot %slot0 : i64-local;
fence %fence0 : cpu;
buffer %buffer0 : gpu<alignment_bits = 4, byte_size = 8>;
event %event0 : local;
scheduling_join %scheduling_join0;
buffer_space %buffer_space0;

function @simple(i64) -> i64;

external-cpu-pure[impl @simple] %do_pure_thing_on_cpu(i64) -> i64;
external-cpu[impl @simple] %do_thing_on_cpu(i64) -> i64;
// the path is required, and is relative to where you run this thing at the moment (unfortunately)
external-gpu[impl @simple] %do_thing_on_gpu(%x : i64) -> [%out : i64]
{
    // I dunno if this is worth cleaning up, probably not
    path : "caiman-test/reference_untested/example.comp",
    entry : "main",
    resource {
        group : 0,
        binding : 0,
        input : %x
    },
    resource {
        group : 0,
        binding : 1,
        output : %out
    }
}

function @simple_32(i32) -> i32;

value[impl @simple_32] %foo(%test : i32) -> [%out : i32] {
    %1 = constant 4i64;
    %2 = extract %1 0;
    %4 = call @simple(%1);
    [%5, %6] = select %1 %2 %4;
    return [%1, %2];
}

value[impl @simple] %y(%abc : i64) -> [i64] {
    jump %abc [%abc, %abc];
}

// can syntactically be empty, even though this is meaningless
schedule[value $val = %foo] %bar<none, none-none>(%0 : %slot0) -> [%out : %slot0] {
    %x = alloc-temporary local i64;
    drop %0;
    %y = static-sub-alloc local i64 %foo.%1;
    [%4, %_] = static-alloc local %0 [1, 2] %foo.%1;
    %z = static-dealloc local %space.%0 [%x, %4];
    %_ = read-ref i64 %x;
    %_ = borrow-ref i64 %x;
    write-ref i64 %x -> %4;
    local-do-builtin %foo.%1(%x, %3) -> [%4, %0];
    local-do-external %do_pure_thing_on_cpu %foo.%1(%x, %3) -> [%4, %0];
    local-copy %x %3;
    %_ = begin-encoding local %foo.%1 [%x, %3] [%4, %0];
    encode-do %x %do_pure_thing_on_cpu %foo.%1() -> %x;
    encode-copy cpu %x %y;
    %6 = submit cpu %foo.%1;
    sync-fence cpu %7 %foo.%2;
    %9 = inline-join %foo [%x, %y] %5;
    %10 = serialized-join %foo [%y, %z] %5;
    %11 = default-join;
    [%_, %_, %_] = promise-captures 5 %x;
    [%_] = fulfill-captures %x [%y, %z] [%3];
    ???;
    return %x;
}

schedule[value $val = %foo, spatial $space = %space]
%scall<none-have, none-met>
(%abc : input($val.%x)-have %slot0)
-> [%out : output($val.%y)-met %slot0] {
    // Note that these are not parser-bound by funclet type, but (should be) managed by the typechecker
    schedule-call %bar[value input(%foo.%x)-have,
        timeline output(%time.%e)-need,
        spatial none-met](%abc, %abc) %abc;
}

// value, timeline, spatial order is mandatory (though you can freely omit one of course)
schedule[value $val = %foo, timeline $time = %tim, spatial $space = %space]
%sselect<input($time.%e)-met, output($time.%e)-have>
(%abc : input($time.%e)-met halt($val.%x)-have %slot0)
-> input($time.%e) output($val.%x) %slot0 {
    schedule-select %abc %bar[value input(%foo.%x)-have,
        timeline output(%time.%e)-need,
        spatial none-met](%abc, %abc) %abc;
}

schedule[value $val = %foo, timeline $time = %time]
%syield<halt($time.%e)-have, node($time.%e)-need>
(%abc : input($space.%bs)-none %event0)
-> [%out : node($space.%bs) %buffer0] {
    schedule-call-yield %bar[value input(%foo.%x)-have,
        timeline output(%time.%e)-need,
        spatial none-met](%abc, %abc) %abc;
}

schedule[value $val = %foo, timeline $time = %time]
%debugtest<halt($time.%e)-have, node($time.%e)-need>
(%abc : input($space.%bs)-none %event0)
-> [%out : node($space.%bs) %buffer0] {
    debug-hole [%abc, %abc]
}

timeline %time(%e : %event0) -> [%event_out : %event0] {
    [%x, %y] = encoding-event %e [%e, %e];
    %1 = submission-event %x;
    %2 = synchronization-event %e %x;
    return %e;
}

spatial %space(%b : %buffer_space0) -> [%iout : i64] {
    [%1, %2, %3] = separated-buffer-space cpu 3 %b;
    return %b;
}

pipeline "pipeline_trivial" = %bar;
