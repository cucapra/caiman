#version 0.1.0

sptl space(s: BufferSpace) -> BufferSpace { returns s }

extern(cpu) pure sum(i64) -> i64

val select_sum(v1: i64, v2: i64, v3: i64) -> out: i64 {
    sum1 :- sum(v1)
    sum2 :- sum(v2)
    sum3 :- sum(v3)
    condition :- sum1 < 0
    result :- sum2 if condition else sum3
    returns result
}

tmln time(in: Event) -> out: Event { 
    local, remote :- encode_event(in)
    sub :- submit_event(remote)
    sync :- sync_event(local, sub)
    returns sync
 }

fn select_sum_impl(
    v1: i64 @ [node(val.v1)], 
    v2: i64 @ [node(val.v2), input(tmln.in)], 
    v3: i64 @ [node(val.v3), input(tmln.in)]
) 
-> i64 @ [node(val.out),  node(tmln.in)] impls select_sum,time,space {
    let sum1 : i64 @ node(val.sum1) = sum(v1);
    let condition : bool @ node(val.condition) = sum1 < 0;
    if @ [node(val.result), input(tmln.in)] condition {
        // let encoder : Encoder @ node(tmln.remote) = encode-begin gpu [v2];
        let sum2 : i64 @ [node(val.sum2), input(tmln.in)] = sum(v2);
        sum2
    }
    else {
        let sum3 : i64 @ [node(val.sum3), input(tmln.in)] = sum(v3);
        sum3
    }
}

pipeline main { select_sum_impl }