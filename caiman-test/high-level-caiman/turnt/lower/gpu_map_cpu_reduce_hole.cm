#version 0.1.0

extern(gpu) simple(x: i32) -> out: i32
{
    path : "gpu_external.comp",
    entry : "main",
    dimensions : 3,
    resource {
        group : 0,
        binding : 0,
        input : x
    },
    resource {
        group : 0,
        binding : 1,
        output : out
    }
}

tmln time(e: Event) -> out: Event {
    loc1, rem1 :- encode_event(e)
    sub1 :- submit_event(rem1)

    loc2, rem2 :- encode_event(loc1, sub1)
    sub2 :- submit_event(rem2)

    snc1 :- sync_event(loc2, sub1)
    snc2 :- sync_event(snc1, sub2)
    returns snc2
}

sptl space(s: BufferSpace) -> BufferSpace {
    returns s
}

val foo(x: i32, z: i32) -> out: i32 {
    c :- 1
    y :- simple'<c, c, c>(x)
    y2 :- simple'<c, c, c>(z)
    returns y + y2
}

fn foo_impl(x: &i32, z: &i32) -> i32 impls foo, space, time {
    ???;
    /* #CHECK:
    Filled(
        Node(
            NamedNode {
                name: Some(
                    NodeId(
                        "[[f_y_ref:[a-zA-Z_0-9:%]+]]",
                    ),
                ),
                node: AllocTemporary {
                    place: Filled(
                        Gpu,
                    ),
                    storage_type: Filled(
                        I32,
                    ),
                    buffer_flags: Filled(
                        BufferFlags {
                            map_read: true,
                            map_write: false,
                            copy_src: false,
                            copy_dst: true,
                            storage: true,
                            uniform: false,
                        },
                    ),
                },
            },
        ),
    ),
    Empty,#END */

    /* #CHECK-NOT:
    node: ReadRef {
        storage_type: Filled(
            I32,
        ),
        source: Filled(
            NodeId(
                "[[f_y_ref]]",
            ),
        ),
    },
    #END */

    let e2 = encode-begin gpu;
    /* #CHECK:
    node: BeginEncoding {
        place: Filled(
            Gpu,
        ),
        event: Filled(
            RemoteNodeId {
                funclet: MetaId(
                    "tmln",
                ),
                node: Some(
                    Filled(
                        NodeId(
                            "_t_loc2_rem2",
                        ),
                    ),
                ),
            },
        ),
        encoded: Filled(
            [
                Filled(
                    NodeId(
                        "e2%0::x2",
                    ),
                ),
                Filled(
                    NodeId(
                        "e2%0::y2",
                    ),
                ),
            ],
        ),
        fences: Filled(
            [
                Filled(
                    NodeId(
                        "f%",
                    ),
                ),
            ],
        ),
    },
    #END */
    encode e2.copy[x2 <- z];
    encode e2.call[y2 <- simple'<1, 1, 1>(x2)];
    let f2 = submit e2;
    let y = (await f).y1;
    /* #CHECK:
    node: LocalCopy {
        input: Filled(
            NodeId(
                "[[f_y_ref]]",
            ),
        ),
        output: Filled(
            NodeId(
                "_t4",
            ),
        ),
    } #END */
    y + (await f2).y2
}

pipeline main { foo_impl }