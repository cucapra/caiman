version 0.0.2

type i32;
slot %slot_local : i32-ready-local;
slot %slot_gpu : i32-ready-local;
event %event0 : local;
buffer %buffer_gpu : gpu<alignment_bits = 0, byte_size = 1024>;
buffer_space %buff_space;

function @simple(i32) -> i32;
function @foo(i32) -> i32;

external-gpu[impl @simple] %simple(%x : i32) -> [%out : i32]
{
    path : "gpu_external.comp",
    entry : "main",
    resource {
        group : 0,
        binding : 0,
        input : %x
    },
    resource {
        group : 0,
        binding : 1,
        output : %out
    }
}

value[impl @foo] %foo(%x : i32) -> i32 {
    %y_t = call @simple(%x);
    %y = extract %y_t 0;
    return %y;
}

timeline %foo_time(%e : %event0) -> %event0 {
    %sub = submission-local->gpu %e;
    %snc = sync-local->gpu %sub %sub;
    return %snc;
}

schedule[value $val = %foo, timeline $time = %foo_time, spatial $space = %foo_space]
%foo_main<input($time.%e), output($time.%e)>
(%s : input($val.%x) %slot_local,
%in_buff : input($space.%bs) %buffer_gpu,
%out_buff : input($space.%bs) %buffer_gpu)
-> [%out : output($val.%x) output($space.%bs) %slot_gpu] {
    %xloc = alloc-gpu-i32 %in_buff %foo.%x;
    %_ = encode-copy-gpu %s %xloc;
    %yloc = alloc-gpu-i32 %out_buff %foo.%y;
    %_ = encode-do-gpu %foo.%y_t(%xloc) -> %yloc;
    %_ = submit-gpu %foo_time.%sub;
    %fnc = encode-fence-gpu %foo_time.%sub;
    %_ = sync-fence-local %fnc %foo_time.%snc;
    return %yloc;
}

spatial %foo_space(%bs : %buff_space) -> %buff_space {
    return %bs;
}

pipeline "main" = %foo_main;