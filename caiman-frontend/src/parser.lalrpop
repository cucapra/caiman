use std::str::FromStr;
use crate::ast::*;

grammar;

match {
  r"[a-zA-Z][a-zA-Z0-9_]*", // Id
  r"[-]?[0-9]+([.][0-9]+)?", // Constant
  r"!BEGIN[^!]*!END", // Shader content

  "Funclet", "CPU", "GPU", "ValueFunction", "Pipeline", "Inline",
  ":", ";", "->", "=>", "=", "_", ",",
  "{", "}", "(", ")", "[", "]", "<", ">", "&", 
	"F32", "F64", "U8", "U16", "U32", "U64", "I8", "I16", "I32", "I64",
  "phi", "extract", "const", "Return", "Yield", "encode", "submit",
  "local", "sync", "mut",
  "WGSL", "BEGIN!", "END!",

  r"\s*" => { }, // Whitespace
  r"//[^\n\r]*[\n\r]*" => { }, // Double-slash comments
}


pub Program: Program = { Declaration* => <> }

pub Declaration: Declaration = {
  <Inline> "Funclet" <Id> <TypeAnnotation> "{" <Node*> <Tail> "}"
      => Declaration::Funclet(<>),
  "CPU" <Id> <TypeAnnotation> ";" 
      => Declaration::CPU(<>),
  "GPU" <Id> "(" <Id> ")" <TypeAnnotation> "{" <Binding*> <Shader?> "}" 
      => Declaration::GPU(<>),
  "ValueFunction" <Id> <("(" <Id> ")")?> <TypeAnnotation> ";"
      => Declaration::ValueFunction(<>),
  "Pipeline" <Id> "(" <Id> ")" ";" 
      => Declaration::Pipeline(<>),
}

Id: String = { r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>) }

TypeAnnotation: FuncType = { 
  ":" <t1: Type> "->" <t2: Type> 
      => (vec![t1], vec![t2]),
  ":" "(" <CommaList<Type>> ")" "->" "(" <CommaList<Type>> ")" => (<>),
}

Tail: FuncletTail = {
  "Return" <CommaList<Id>> => FuncletTail::Return(<>),
  "Yield" <CommaList<Id>> "{" <CommaList<Id>> "=>" <CommaList<Id>> "}"
      => FuncletTail::Yield(<>),
}

NodeType: NodeType = {
  "phi" <Index> 
      => NodeType::Phi(<>),
  "extract" <s: Id> 
      => NodeType::Extract(s, 0),
  "extract" <Id> "[" <Index> "]" 
      => NodeType::Extract(<>),
  "const" <Constant> ":" <Type> 
      => NodeType::Constant(<>),
  <Id> "(" <CommaList<Id>> ")" 
      => NodeType::Call(<>),
  <Id> "<" <CommaList<Id>> ">" "(" <CommaList<Id>> ")" 
      => NodeType::GPUCall(<>),
  "GPU" "encode" "(" <CommaList<Id>> ")" 
      => NodeType::GPUEncode(<>),
  "GPU" "submit" "(" <CommaList<Id>> ")" 
      => NodeType::GPUSubmit(<>),
  "local" "sync" "(" <CommaList<Id>> ")" 
      => NodeType::LocalSync(<>),
}

Node: Node = { <Id> "=" <NodeType> ";" => (<>) }

Inline: bool = { <o: "Inline"?> => o.is_some() }

Index: usize = { 
  <Constant> => usize::from_str(&<>).unwrap() 
}

Constant: String = {
  <r"[-]?[0-9]+([.][0-9]+)?"> => String::from(<>),
}

Type: Type = {
	"F32" => Type::F32,
	"F64" => Type::F64,
	"U8" => Type::U8,
	"U16" => Type::U16,
	"U32" => Type::U32,
	"U64" => Type::U64,
	"I8" => Type::I8,
	"I16" => Type::I16,
  "I32" => Type::I32,
	"I64" => Type::I64,
  "[" <t: Type> ";" <l: Index> "]" => Type::Array(Box::new(t), l),
  "&" <t: Type> => Type::Ref(Box::new(t)),
  "&" "mut" <t: Type> => Type::MutRef(Box::new(t)),
  "&" "[" <t: Type> "]" => Type::Slice(Box::new(t)),
  "&" "mut" "[" <t: Type> "]" => Type::MutSlice(Box::new(t)),
}

ShaderType: ShaderType = {
  "WGSL" => ShaderType::Wgsl,
}

ShaderContent: String = { 
  <s: r"!BEGIN[^!]*!END"> => String::from(&s[6 .. s.len() - 4])
}

Shader: Shader = {
  <ShaderType> <ShaderContent> => (<>)
}


BindingOption: Option<usize> = {
  <Index> => Some(<>),
  "_" => None,
}

Binding: ResourceBinding = {
  "[" <n1: Index> "]" "[" <n2: Index> "]" "=" 
      <b1: BindingOption> "->" <b2: BindingOption> ";" 
        => ResourceBinding { group: n1, binding: n2, input: b1, output: b2 }
}

CommaList<T>: Vec<T> = {
  <mut v: (<T> ",")*> <e: T?> => match e { 
      None => v, 
      Some(e) => {
          v.push(e);
          v
      },
  }
}

