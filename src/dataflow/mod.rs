use crate::convert::Convert;
use crate::ir;
use std::mem::replace;
use thiserror::Error;

mod from_ir;
mod into_ir;

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct NodeIndex(usize);

// Pulls in Operation enum & inherent methods
include!(concat!(env!("OUT_DIR"), "/generated/dataflow_base.rs"));

// TODO: This may be autogenerated in the future
enum Tail {
    Return {
        return_values: Box<[NodeIndex]>,
    },
    Yield {
        funclet_ids: Box<[ir::FuncletId]>,
        captured_arguments: Box<[NodeIndex]>,
        return_values: Box<[NodeIndex]>,
    },
}
impl Tail {
    fn for_each_dependency(&self, mut f: impl FnMut(&NodeIndex)) {
        match self {
            Self::Return { return_values } => return_values.iter().for_each(&mut f),
            Self::Yield {
                captured_arguments,
                return_values,
                ..
            } => {
                captured_arguments.iter().for_each(&mut f);
                return_values.iter().for_each(&mut f);
            }
        }
    }
}

#[derive(Debug, Error)]
pub enum Error {
    #[error("failed to translate IR to dataflow graph")]
    FromIr(#[from] from_ir::Error),
}

enum Node {
    /// A node containing an operation.
    Operation(Operation),

    /// A reference to another node. When operating on a reference node, you traverse the
    /// "linked list" of references until a Node::Operation is found and operate on that instead.
    ///
    /// # Why references?
    ///
    /// Suppose you have identical nodes A and B. You'll want to merge A and B into a single node.
    /// Normally, this would mean taking all incoming edges for A and B and assigning them to the
    /// merged node. For complex technical reasons, [`Graph`] doesn't keep track of incoming edges,
    /// so iterating over incoming edges would be very expensive.
    ///
    /// We can make B into a reference to A instead. That way we don't need to modify any of the
    /// nodes which depend on B.
    Reference(NodeIndex),
}
pub struct Graph {
    nodes: Vec<Node>,
    tail: Tail,
}
impl Graph {
    pub fn from_ir(ir_nodes: Vec<ir::Node>, ir_tail: ir::TailEdge) -> Result<Self, Error> {
        let mut nodes = Vec::with_capacity(ir_nodes.len());
        for (i, ir_node) in ir_nodes.into_iter().enumerate() {
            let context = from_ir::Context::new(i);
            let operation = ir_node.convert(&context)?;
            nodes.push(Node::Operation(operation));
        }
        let tail = {
            let context = from_ir::Context::new(nodes.len());
            ir_tail.convert(&context)?
        };
        Ok(Self { nodes, tail })
    }
    /// Returns the index of the node containing the operation referenced by `index`.
    /// (This may be the same as `index`.) It's guaranteed that the node at the resulting index
    /// will be a [`Node::Operation`].
    fn resolve_index(&self, mut index: NodeIndex) -> NodeIndex {
        loop {
            match &self.nodes[index.0] {
                Node::Operation(_) => return index,
                Node::Reference(next) if *next == index => panic!("Reference cycle"),
                Node::Reference(next) => index = *next,
            }
        }
    }
    /// Retrieves a reference to the operation associated with `index`.
    pub fn operation(&self, index: NodeIndex) -> &Operation {
        let real_index = self.resolve_index(index);
        match &self.nodes[real_index.0] {
            Node::Operation(operation) => operation,
            Node::Reference(_) => unreachable!(),
        }
    }
    /// Retrieves a mutable reference to the operation associated with the `index`.
    pub fn operation_mut(&mut self, index: NodeIndex) -> &mut Operation {
        let real_index = self.resolve_index(index);
        match &mut self.nodes[real_index.0] {
            Node::Operation(operation) => operation,
            Node::Reference(_) => unreachable!(),
        }
    }
    /// Makes the node at `src` into a reference to `dst`. Note that there is no way to convert
    /// a node from a reference back into an operation -- this is to make it easier to reason
    /// about correctness.
    pub fn make_reference(&mut self, src: NodeIndex, dst: NodeIndex) {
        let real_src = self.resolve_index(src);
        // strictly speaking, we don't need to resolve dst, but it might help performance
        let real_dst = self.resolve_index(dst);
        self.nodes[real_src.0] = Node::Reference(real_dst);
    }
    pub fn into_ir(mut self) -> (Vec<ir::Node>, ir::TailEdge) {
        fn visit(
            index: NodeIndex,
            graph: &mut Graph,
            ir_nodes: &mut Vec<ir::Node>,
            context: &mut into_ir::Context,
        ) {
            if context.is_fully_visited(index) {
                return;
            }
            context.begin_visit(index);
            let operation = replace(graph.operation_mut(index), Operation::None {});
            operation.for_each_dependency(|&index| {
                visit(index, graph, ir_nodes, context);
            });
            let node_id = ir_nodes.len();
            ir_nodes.push(operation.convert(context).unwrap());
            context.finish_visit(index, node_id);
        }

        let mut ir_nodes = Vec::new();
        let mut context = into_ir::Context::new();

        let tail = replace(
            &mut self.tail,
            Tail::Return {
                return_values: Box::new([]),
            },
        );

        tail.for_each_dependency(|&index| {
            visit(index, &mut self, &mut ir_nodes, &mut context);
        });

        let ir_tail = tail.convert(&context).unwrap();
        (ir_nodes, ir_tail)
    }
}
