#![warn(warnings)]
use crate::ir;
use std::collections::HashMap;
use thiserror::Error;

mod operations;
pub use operations::Operation;
pub mod traversals;

#[derive(Debug, Error)]
pub enum IrDependent {
    /// Represents the [`ir::Node`](crate::ir) specified by it's node ID in a given funclet.
    Node(ir::NodeId),
    /// Represents the [`ir::TailEdge`](crate::ir) of a given funclet.
    Tail,
}
impl std::fmt::Display for IrDependent {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Node(id) => write!(f, "IR node (id: {id})"),
            Self::Tail => write!(f, "IR tail edge"),
        }
    }
}

#[derive(Debug, Error)]
pub enum Error {
    /// This error is produced when an [`ir::Node`](crate::ir) or [`ir::TailEdge`](crate::ir)
    /// depends on a node which:
    /// 1. occurs after the dependency, or
    /// 2. doesn't exist at all
    #[error("{required_by} incorrectly depends on IR node #{dependency}")]
    IrDependency {
        /// The ID of the dependency
        dependency: ir::NodeId,
        /// The ID of the node which caused the failure.
        required_by: IrDependent,
    },
    #[error(transparent)]
    DependencyCycle(#[from] traversals::DependencyCycle),
}

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct NodeIndex(usize);
impl NodeIndex {
    fn from_ir_dependency(
        dependency: ir::NodeId,
        required_by: IrDependent,
        sentinel: ir::NodeId,
    ) -> Result<Self, Error> {
        if dependency >= sentinel {
            Err(Error::IrDependency {
                dependency,
                required_by,
            })
        } else {
            Ok(NodeIndex(dependency))
        }
    }
}

// TODO: This may be autogenerated in the future
enum Tail {
    Return {
        return_values: Box<[NodeIndex]>,
    },
    Yield {
        funclet_ids: Box<[ir::FuncletId]>,
        captured_arguments: Box<[NodeIndex]>,
        return_values: Box<[NodeIndex]>,
    },
}
impl Tail {
    fn from_ir(ir_tail: &ir::TailEdge, sentinel: ir::NodeId) -> Result<Self, Error> {
        fn cvt_ids<'a>(
            ids: impl Iterator<Item = &'a ir::NodeId>,
            sentinel: ir::NodeId,
        ) -> Result<Box<[NodeIndex]>, Error> {
            ids.map(|dependency| {
                NodeIndex::from_ir_dependency(*dependency, IrDependent::Tail, sentinel)
            })
            .collect()
        }
        match ir_tail {
            ir::TailEdge::Return { return_values } => Ok(Self::Return {
                return_values: cvt_ids(return_values.iter(), sentinel)?,
            }),
            ir::TailEdge::Yield {
                funclet_ids,
                captured_arguments,
                return_values,
            } => Ok(Self::Yield {
                funclet_ids: funclet_ids.clone(),
                captured_arguments: cvt_ids(captured_arguments.iter(), sentinel)?,
                return_values: cvt_ids(return_values.iter(), sentinel)?,
            }),
        }
    }
    fn to_ir(&self, node_map: &HashMap<NodeIndex, ir::NodeId>) -> ir::TailEdge {
        match self {
            Self::Return { return_values } => ir::TailEdge::Return {
                return_values: return_values.iter().map(|id| node_map[id]).collect(),
            },
            Self::Yield {
                funclet_ids,
                captured_arguments,
                return_values,
            } => ir::TailEdge::Yield {
                funclet_ids: funclet_ids.clone(),
                captured_arguments: captured_arguments.iter().map(|id| node_map[id]).collect(),
                return_values: return_values.iter().map(|id| node_map[id]).collect(),
            },
        }
    }
    fn for_each_dependency(&self, mut f: impl FnMut(&NodeIndex)) {
        match self {
            Self::Return { return_values } => return_values.iter().for_each(&mut f),
            Self::Yield {
                captured_arguments,
                return_values,
                ..
            } => {
                captured_arguments.iter().for_each(&mut f);
                return_values.iter().for_each(&mut f);
            }
        }
    }
}

enum Node {
    /// A node containing an operation.
    Operation(Operation),

    /// A reference to another node. When operating on a reference node, you traverse the
    /// "linked list" of references until a Node::Operation is found and operate on that instead.
    ///
    /// # Why references?
    ///
    /// Suppose you have identical nodes A and B. You'll want to merge A and B into a single node.
    /// Normally, this would mean taking all incoming edges for A and B and assigning them to the
    /// merged node. For complex technical reasons, [`Graph`] doesn't keep track of incoming edges,
    /// so iterating over incoming edges would be very expensive.
    ///
    /// We can make B into a reference to A instead. That way we don't need to modify any of the
    /// nodes which depend on B.
    Reference(NodeIndex),
}

pub struct Graph {
    nodes: Vec<Node>,
    tail: Tail,
}
impl Graph {
    pub fn from_ir(ir_nodes: &[ir::Node], ir_tail: &ir::TailEdge) -> Result<Self, Error> {
        let mut nodes = Vec::with_capacity(ir_nodes.len());
        for (i, ir_node) in ir_nodes.iter().enumerate() {
            let operation = Operation::from_ir(ir_node, i)?;
            nodes.push(Node::Operation(operation));
        }
        let tail = Tail::from_ir(ir_tail, ir_nodes.len())?;
        Ok(Self { nodes, tail })
    }
    /// Returns the index of the node containing the operation referenced by `index`.
    /// (This may be the same as `index`.) It's guaranteed that the node at the resulting index
    /// will be a [`Node::Operation`].
    fn resolve_index(&self, mut index: NodeIndex) -> NodeIndex {
        loop {
            // I'm pretty sure reference cycles are impossible if you only use the `pub` functions
            // Worst case scenario, they're not & we get an infinite loop (easy to debug)
            match &self.nodes[index.0] {
                Node::Operation(_) => return index,
                Node::Reference(next) => index = *next,
            }
        }
    }
    /// Retrieves a reference to the operation associated with `index`.
    pub fn operation(&self, index: NodeIndex) -> &Operation {
        let real_index = self.resolve_index(index);
        match &self.nodes[real_index.0] {
            Node::Operation(operation) => operation,
            Node::Reference(_) => unreachable!(),
        }
    }
    /// Retrieves a mutable reference to the operation associated with `index`.
    pub fn operation_mut(&mut self, index: NodeIndex) -> &mut Operation {
        let real_index = self.resolve_index(index);
        match &mut self.nodes[real_index.0] {
            Node::Operation(operation) => operation,
            Node::Reference(_) => unreachable!(),
        }
    }
    /// Makes the node at `src` into a reference to `dst`. Note that there is no way to convert
    /// a node from a reference back into an operation -- this is to make it easier to reason
    /// about correctness.
    pub fn make_reference(&mut self, src: NodeIndex, dst: NodeIndex) {
        let real_src = self.resolve_index(src);
        // strictly speaking, we don't need to resolve dst, but it might help performance
        let real_dst = self.resolve_index(dst);
        self.nodes[real_src.0] = Node::Reference(real_dst);
    }
    pub fn into_ir(&self) -> Result<(Vec<ir::Node>, ir::TailEdge), Error> {
        let mut ir_nodes = Vec::new();
        let mut node_map = HashMap::new();
        let mut traversal = traversals::DependencyFirst::new(&self);
        while let Some(index) = traversal.next(self)? {
            ir_nodes.push(self.operation(index).to_ir(&node_map));
            node_map.insert(index, node_map.len());
        }
        let ir_tail = self.tail.to_ir(&node_map);
        Ok((ir_nodes, ir_tail))
    }
}
