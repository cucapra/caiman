use crate::value_language::ast::*;
use crate::value_language::typing::Type;
use crate::value_language::ast_factory::ASTFactory;
use crate::spec;

grammar(astf: &ASTFactory);

match {
  r"[a-zA-Z][a-zA-Z0-9_]*", // Id
  r"[-]?[0-9]+([.][0-9]+)?", // Constant

  "let", "mut", "input", "print", "if", "while", "fn", "return", "else",
  "=", ";", "(", ")", ",", "{", "}", ":", "->",
  "+", "-", "*", "/", "&&", "||", "!", "@",
  "true", "false",
  "i32", "bool",

  r"\s*" => { }, // Whitespace
  r"//[^\n\r]*[\n\r]*" => { }, // Double-slash comments

  _,
}

pub Program: ParsedProgram = { Stmt* => <> }

pub Stmt: ParsedStmt = {
    //"let" <Let>,
    <@L> "let" <VarWithType> "=" <Expr> ";" <@R>  => astf.let_stmt(<>),
    <@L> "let" <Id> <FunctionArg+>
      "->" <Type> "{" <Stmt*> <Expr> "}" <@R>     => astf.let_function(<>),
}

FunctionArg: VarWithType = {
  "(" <VarWithType> ")",
}

VarWithType: VarWithType = {
    <Id> ":" <Type>,
}

Expr: ParsedExpr = {
    TermExpr, 
}

TermExpr: ParsedExpr = {
    <@L> <Constant> <@R>                          => astf.num(<>),
    <@L> <Id> <@R>                                => astf.var(<>),
    <@L> "(" ")" <@R>                             => astf.unit(<>),
    <@L> <Bool> <@R>                              => astf.bool_expr(<>),
    <@L> <IRNodeE> "(" <CommaList<Expr>> ")" <@R> => astf.ir_node_expr(<>),
    <@L> "(" "if" <Expr> <Expr> <Expr> ")" <@R>   => astf.if_expr(<>),
    <@L> "(" <Id> <Expr+> ")" <@R>                => astf.ecall(<>),
    // TODO not this! Make it like function call
    <@L> "(" <Binop> <Expr> <Expr> ")" <@R>       => astf.binop(<>),
    <@L> "(" <OnePlusCommaList<Expr>> ")" <@R>    => astf.tuple(<>),
    <@L> "(" <Expr> "@" <Id> ")" <@R>             => astf.labeled(<>), 
    UnopExpr, 
    "(" <Expr> ")",
}

Bool: bool = {
  "true" => true,
  "false" => false,
}

UnopExpr: ParsedExpr = {
    <@L> "(" <UnopNot> <TermExpr> ")" <@R> => astf.unop(<>),
}

UnopNot: Unop = { "!" => Unop::Not }

// BEGIN Binop Section
// Numbers here (1, 2, ...) indicate predence level for levels containing
// two or more options (so not And or Or)

Binop: Binop = { 
  "&&" => Binop::And, 
  "||" => Binop::Or, 
  "=" => Binop::Equals,
  "+" => Binop::Plus,
  "-" => Binop::Minus,
  "*" => Binop::Mult,
  "/" => Binop::Div,
}

// END Binop Section

Id: String = { r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>) }

Constant: String = {
    <r"[-]?[0-9]+([.][0-9]+)?"> => String::from(<>),
}

CommaList<T>: Vec<T> = {
    <mut v: (<T> ",")*> <e: T?> => match e { 
        None => v, 
        Some(e) => {
            v.push(e);
            v
        },
    }
}

Type: Type = {
    "i32" => Type::I32,
    "bool" => Type::Bool,
}

OnePlusCommaList<T>: Vec<T> = {
    <e_start: T> "," <mut v: (<T> ",")*> <e_end: T?> => {
        if let Some(e) = e_end {
            v.push(e);
        }
        v.insert(0, e_start);
        v
    }
}
IRNodeE: spec::nodes::FunctionalExprNodeKind = {
"IR::Phi" => spec::nodes::FunctionalExprNodeKind::Phi,
"IR::ExtractResult" => spec::nodes::FunctionalExprNodeKind::ExtractResult,
"IR::Constant" => spec::nodes::FunctionalExprNodeKind::Constant,
"IR::CallFunctionClass" => spec::nodes::FunctionalExprNodeKind::CallFunctionClass,
"IR::Select" => spec::nodes::FunctionalExprNodeKind::Select,
}
