#version 0.1.0

// similar to hlc_gpu_call_sync, but instead of passing a fence, pass an encoder

extern(gpu) simple(x : i32) -> out: i32
{
    path : "gpu_external.comp",
    entry : "main",
    dimensions : 3,
    in {
        group : 0,
        binding : 0,
        input : x
    },
    out {
        group : 0,
        binding : 1,
        output : out
    }
}

val foo(x : i32) -> out: i32 {
    y :- simple'<1, 1, 1>(x)
    y2 :- bar(y)
    returns y2
}

val bar(x : i32) -> out: i32 {
    y :- simple'<1, 1, 1>(3)
    returns x + y
}

tmln bar_time(e: Event, r: Event) -> out: Event {
    loc, rem :- encode_event(e)
    sub :- submit_event(rem)
    sub2 :- submit_event(r)
    snc1 :- sync_event(loc, sub)
    snc2 :- sync_event(snc1, sub2)
    returns snc2
}

tmln foo_time(e: Event) -> out: Event {
    loc, rem :- encode_event(e)
    ret :- bar_time(loc, rem)
    returns ret
}

sptl space(bs: BufferSpace) -> BufferSpace {
    returns bs
}


fn foo_impl(x: &i32 @ node(tmln.rem)) -> i32 impls foo_time, foo, space {
    @in { input: input(tmln.e), output: node(tmln.out) };
    let e = encode-begin @ node(tmln.(loc, rem)) { x_gpu, y_gpu } gpu;
    encode e.copy[x_gpu <- x];
    encode e.call[y_gpu <- simple'<1, 1, 1>(x_gpu)];
    let r = bar_impl(e, y_gpu) @ node(tmln.ret);
    @in {input: node(tmln.ret), output: node(tmln.out) };
    @out {input: node(tmln.out), output: node(tmln.out) };
    r
}

fn bar_impl(e2: Encoder @ [input(tmln.r), none(val)], 
            x: i32'<storage, map_read> @ [input(tmln.r), none(sptl)-saved]) -> i32 
            impls bar_time, bar, space 
{
    @in { input: input(tmln.e), output: node(tmln.out) };
    let e = encode-begin @ node(tmln.(loc, rem)) { x_gpu, y_gpu } gpu;
    let t: i32 = 3;
    encode e.copy[x_gpu <- t];
    encode e.call[y_gpu <- simple'<1, 1, 1>(x_gpu)];
    let f2 = submit @ node(tmln.sub) e;
    let f = submit @ node(tmln.sub2) e2;
    let y = (await @ node(tmln.snc1) f2).y_gpu;
    // TODO: we rename nodes normally, but currently aren't doing
    // that for timeline stuff. Hence the `x_0` to "manually" rename
    let x2 = (await @ node(tmln.snc2) f).x_0;
    @out { input: node(tmln.out), output: node(tmln.out) };
    x2 + y
}

pipeline main { foo_impl }