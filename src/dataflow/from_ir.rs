use super::{NodeIndex, Operation, Tail};
use crate::convert::{ConversionContext, Convert};
use crate::ir;
use thiserror::Error;

#[derive(Debug, Error)]
pub enum Error {
    /// This error is produced when an [`ir::Node`](crate::ir) depends on another node which:
    /// 1. occurs after the dependent node, or
    /// 2. doesn't exist at all
    #[error("ir::Node #{dependent} has invalid dependency on ir::Node #{dependency}")]
    InvalidDependency {
        /// The ID of the node which caused the failure.
        dependent: ir::NodeId,
        /// The ID of the dependency
        dependency: ir::NodeId,
    },
}

/// Context used for IR-to-dataflow conversions.
/// HACK: Right now we add nodes to the graph in the same order as nodes in the IR, and both
/// NodeIndex and ir::NodeId are *really* just a usize, so we can use a 1-to-1 mapping.
/// This will probably have to change in the future.
pub struct Context {
    /// ID of the current node, used for error reporting
    cur_id: ir::NodeId,
}
impl Context {
    pub fn new(cur_id: ir::NodeId) -> Self {
        Self { cur_id }
    }
    /// Retrieves the node index associated with the IR node given by `id`.
    pub fn index_for_id(&self, id: ir::NodeId) -> Result<NodeIndex, Error> {
        // HACK: this only works as long as ir::NodeId is just a usize
        if id >= self.cur_id {
            Err(Error::InvalidDependency {
                dependent: self.cur_id,
                dependency: id,
            })
        } else {
            Ok(NodeIndex(id))
        }
    }
}
impl ConversionContext for Context {
    type Error = Error;
}

impl Convert<NodeIndex, Context> for &ir::NodeId {
    fn convert(self, context: &Context) -> Result<NodeIndex, Error> {
        context.index_for_id(*self)
    }
}
impl Convert<Box<[NodeIndex]>, Context> for &Box<[ir::NodeId]> {
    fn convert(self, context: &Context) -> Result<Box<[NodeIndex]>, Error> {
        self.iter().map(|id| id.convert(context)).collect()
    }
}
impl Convert<Operation, Context> for &ir::Node {
    fn convert(self, context: &Context) -> Result<Operation, Error> {
        include!(concat!(env!("OUT_DIR"), "/generated/dataflow_from_ir.txt"))
    }
}
// TODO: This may be autogenerated in the future
impl Convert<Tail, Context> for &ir::TailEdge {
    fn convert(self, context: &Context) -> Result<Tail, Error> {
        Ok(match self {
            ir::TailEdge::Return { return_values } => Tail::Return {
                return_values: return_values.convert(context)?,
            },
            ir::TailEdge::Yield {
                funclet_ids,
                captured_arguments,
                return_values,
            } => Tail::Yield {
                funclet_ids: funclet_ids.convert(context)?,
                captured_arguments: captured_arguments.convert(context)?,
                return_values: return_values.convert(context)?,
            },
        })
    }
}
