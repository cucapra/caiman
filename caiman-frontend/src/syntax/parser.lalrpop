use super::ast::*;
use super::ast_factory::ASTFactory;

grammar(astf: &ASTFactory);

match {
  r"[a-zA-Z][a-zA-Z0-9_]*", // Id
  r"[-]?[0-9]+([.][0-9]+)?", // Constant

  // Keywords (omitting things with symbols in here is ok for some reason)
  "value", "function", "class", "schedule", "fn", "timeline", "pipeline",
  "let", "returns", "return",
  "i32", "i64", "bool", "Event",
  "at", "and", "space", "time",
  "Prim",


  r"\s*" => { }, // Whitespace
  r"//[^\n\r]*[\n\r]*" => { }, // Double-slash comments

  _, // Everything else
}


pub Program: Program = { Decl* => <> }

Decl: Decl = {
    <@L> 
    "value" <Id> "(" <CommaList<Arg<ValueType>>> ")" "->" <ValueOutput> 
    "{" 
         <ValueStmt*> 
    "}" 
    <@R> => astf.value_funclet(<>),

    <@L> 
    "function" "class" <Id> "{" <CommaList<Id>> "}" 
    <@R> => astf.function_class(<>),

    <@L>
    "schedule" <Id> "{" <SchedulingFunclet*> "}"
    <@R> => astf.schedule_block(<>),

    <@L>
    "timeline" <Id> "(" <CommaList<Arg<TimeType>>> ")" "->" <TimeType>
    "{"
        <TimeStmt*>
    "}"
    <@R> => astf.timeline_funclet(<>),

    <@L> "pipeline" <Id> "=" <Id> ";" <@R> => astf.pipeline(<>),
}

// VALUE LANGUAGE SECTION

ValueType: value::Type = {
    "i32"  => value::Type::Num(value::NumberType::I32),
    "i64"  => value::Type::Num(value::NumberType::I64),
    "bool" => value::Type::Bool,
}

ValueOutput: (Option<String>, value::Type) = {
  <t: ValueType> => (None, t),
  // TODO add named output
}

ValueStmt: value::Stmt = {
    <@L> "let" <Id> "=" <ValueExpr> "." <@R>         => astf.value_let(<>),
    <@L> "returns" <ValueExpr> "." <@R>              => astf.value_returns(<>),
}

ValueExpr: value::Expr = {
    <@L> <Id> <@R>                                   => astf.value_var(<>),
    <@L> <Bool> <@R>                                 => astf.value_bool(<>),
    <@L> <ValueNumber> <@R>                          => astf.value_number(<>),
    "(" <ValueExpr> ")",
}

Bool: bool = {
    "true" => true,
    "false" => false,
}

ValueNumber: (String, value::NumberType) = {
    <n: r"[-]?[0-9]+([.][0-9]+)?"> => (String::from(n), value::NumberType::I64),
    // TODO: adding the lil type tag after the number (i64 will be default tho)
}

// SCHEDULE LANGUAGE SECTION

SchedulingFunclet: scheduling::SchedulingFunclet = {
    <@L>
    "fn" <Id> "(" <CommaList<Arg<SchType>>> ")" "->" <SchType>
      <TimeSpaceTags?> 
    "{" 
      <SchStmt*>
    "}"
    <@R> => astf.scheduling_funclet(<>),
}

TimeSpaceTags: (Option<String>, Option<String>) = {
    "at" "time" <t: Id> "and" "space" <s: Id> => (Some(t), Some(s)),
    "at" "space" <s: Id> "and" "time" <t: Id> => (Some(t), Some(s)),
    "at" "time" <t: Id> => (Some(t), None),
    "at" "space" <s: Id> => (None, Some(s)),
}

SchType: scheduling::Type = {
    "&" <Id> => scheduling::Type::Slot(<>),
}

SchStmt: scheduling::Stmt = {
    <@L> "let" <Id> ":=" <SchExpr> ";" <@R>     => astf.sch_let(<>),
    <@L> "return" <Id> ";" <@R>                 => astf.sch_return(<>),
}

SchExpr: scheduling::ScheduledExpr = {
    <@L> <Id> "." <SchFull> <@R> => astf.sch_expr(<>),
}

SchFull: scheduling::FullSchedulable = {
    "Prim" => scheduling::FullSchedulable::Primitive,
}

// TIMELINE FUNCLET SECTION

TimeType: timeline::Type = {
    "Event" => timeline::Type::Event,
}

TimeStmt: timeline::Stmt = {
    <@L> "return" <Id> ";" <@R> => astf.time_return(<>),
}


Arg<T>: Arg<T> = { <i: Id> ":" <t: T> => (i, t) }


Id: String = { r"[a-zA-Z][a-zA-Z0-9_]*" => String::from(<>) }

CommaList<T>: Vec<T> = {
    <mut v: (<T> ",")*> <e: T?> => match e { 
        None => v, 
        Some(e) => {
            v.push(e);
            v
        },
    }
}
