const $N 64;

value vadd2(v1 : array<i32, $N>, v2 : array<i32, $N>, 
v3 : array<i32, $N>) -> array<i32, $N> {
    let tmp = @vadd(v1, v2).
    let result = @vadd(tmp, v3).
    returns result.
}

function @vadd(array<i32, $N>, array<i32, $N>) -> array<i32, $N>;

external-cpu[impl @vadd] extern_vadd;

value[impl default @vadd] vadd(v1 : array<i32, $N>, v2 : array<i32, $N>) {
    rec := (@vadd v1.tl v2.tl).
    val := (+ v1.hd v2.hd).
    result := (if (@empty v1) [] (@append rec val)).
    returns result.
}

slot-cpu arrc : array<i32, $N>;
slot-gpu arrg : array<i32, $N>;

schedule vadd2 {
    fn vadd2_cpu(v1_slot : arrc, v2_slot : arrc, v3_slot : arrc) -> arrc {
        tmp_slot <- vadd_cpu[tmp](v1_slot, v2_slot);
        result_slot <- vadd_cpu[result](tmp_slot, v3_slot);
        return result_slot;
    }
}

schedule vadd {
    fn vadd_cpu(v1_slot : arrc, v2_slot : arrc) -> arrc {
        // allocate
        new_arr_slot <- new_arr(arrc, $N);
        result_slot <- result[vadd_rec_cpu]
            (v1_slot, v2_slot, new_arr_slot);
        return result_slot;
    }

    fn vadd_cpu_rec(
    v1_slot : arrc, 
    v2_slot : arrc,
    result_slot: arrc) -> arrc {
        length_slot <- alloc-cpu u32;
        zero_slot <- alloc_cpu u32; 
        length_slot <- length(v1_slot);
        zero_slot <- const_cpu(0, u32);
        result_slot <- if (eq_cpu(length_slot, zero_slot)) {
            // split stuff
        } else {
            result_slot <- 
        }
        return result_slot;
    }
}