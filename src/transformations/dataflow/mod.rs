use crate::ir;
use thiserror::Error;

mod from_ir;
mod to_ir;

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct NodeIndex(usize);

// Pulls in Operation enum & inherent methods
include!(concat!(env!("OUT_DIR"), "/generated/dataflow_base.rs"));

// TODO: This may be autogenerated in the future
enum Tail {
    Return {
        return_values: Box<[NodeIndex]>,
    },
    Yield {
        funclet_ids: Box<[ir::FuncletId]>,
        captured_arguments: Box<[NodeIndex]>,
        return_values: Box<[NodeIndex]>,
    },
}
impl Tail {
    fn for_each_dependency(&self, mut f: impl FnMut(&NodeIndex)) {
        match self {
            Self::Return { return_values } => return_values.iter().for_each(&mut f),
            Self::Yield {
                captured_arguments,
                return_values,
                ..
            } => {
                captured_arguments.iter().for_each(&mut f);
                return_values.iter().for_each(&mut f);
            }
        }
    }
}

#[derive(Debug, Error)]
pub enum Error {
    #[error("failed to translate IR to dataflow graph")]
    FromIr(#[from] from_ir::Error),
}

enum Node {
    /// A node containing a value-producing operation.
    Operation(Operation),

    /// A reference to another node. The referenced node *must* be an operation, and not another
    /// reference; this is done to ensure O(1) operation access and simplify cycle detection.
    ///
    /// # Why references?
    ///
    /// Suppose you have identical nodes A and B. You'll want to merge A and B into a single node.
    /// Normally, this would mean taking all incoming edges for A and B and assigning them to the
    /// merged node. For complex technical reasons, [`Graph`] doesn't keep track of incoming edges,
    /// so iterating over incoming edges would be very expensive.
    ///
    /// We can make B into a reference to A instead. That way we don't need to modify any of the
    /// nodes which depend on B.
    Reference(NodeIndex),
}

pub struct Graph {
    nodes: Vec<Node>,
    tail: Tail,
}
impl Graph {
    fn new(ir_nodes: Vec<ir::Node>, tail: ir::TailEdge) -> Result<Self, Error> {
        todo!()
    }
    fn into_ir(self) -> Result<(Vec<ir::Node>, ir::TailEdge), Error> {
        todo!()
    }
}
