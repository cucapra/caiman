use crate::convert::Convert;
use crate::ir;
use std::mem::replace;
use thiserror::Error;

mod from_ir;
mod into_ir;

#[derive(Debug, Clone, Copy, Hash, PartialEq, Eq)]
pub struct NodeIndex(usize);

// Pulls in Operation enum & inherent methods
include!(concat!(env!("OUT_DIR"), "/generated/dataflow_base.rs"));

// TODO: This may be autogenerated in the future
enum Tail {
    Return {
        return_values: Box<[NodeIndex]>,
    },
    Yield {
        funclet_ids: Box<[ir::FuncletId]>,
        captured_arguments: Box<[NodeIndex]>,
        return_values: Box<[NodeIndex]>,
    },
}
impl Tail {
    fn for_each_dependency(&self, mut f: impl FnMut(&NodeIndex)) {
        match self {
            Self::Return { return_values } => return_values.iter().for_each(&mut f),
            Self::Yield {
                captured_arguments,
                return_values,
                ..
            } => {
                captured_arguments.iter().for_each(&mut f);
                return_values.iter().for_each(&mut f);
            }
        }
    }
}

#[derive(Debug, Error)]
pub enum Error {
    #[error("failed to translate IR to dataflow graph")]
    FromIr(#[from] from_ir::Error),
}

enum Node {
    /// A node containing a value-producing operation.
    Operation(Operation),

    /// A reference to another node. The referenced node *must* be an operation, and not another
    /// reference; this is done to ensure O(1) operation access and simplify cycle detection.
    ///
    /// # Why references?
    ///
    /// Suppose you have identical nodes A and B. You'll want to merge A and B into a single node.
    /// Normally, this would mean taking all incoming edges for A and B and assigning them to the
    /// merged node. For complex technical reasons, [`Graph`] doesn't keep track of incoming edges,
    /// so iterating over incoming edges would be very expensive.
    ///
    /// We can make B into a reference to A instead. That way we don't need to modify any of the
    /// nodes which depend on B.
    Reference(NodeIndex),
}
pub struct Graph {
    nodes: Vec<Node>,
    tail: Tail,
}
impl Graph {
    pub fn from_ir(ir_nodes: Vec<ir::Node>, ir_tail: ir::TailEdge) -> Result<Self, Error> {
        let mut nodes = Vec::with_capacity(ir_nodes.len());
        for (i, ir_node) in ir_nodes.into_iter().enumerate() {
            let context = from_ir::Context::new(i);
            let operation = ir_node.convert(&context)?;
            nodes.push(Node::Operation(operation));
        }
        let tail = {
            let context = from_ir::Context::new(nodes.len());
            ir_tail.convert(&context)?
        };
        Ok(Self { nodes, tail })
    }
    fn operation(&self, index: NodeIndex) -> &Operation {
        match &self.nodes[index.0] {
            Node::Operation(operation) => operation,
            Node::Reference(index) => self.operation(*index),
        }
    }
    fn operation_mut(&mut self, mut index: NodeIndex) -> &mut Operation {
        // This code is a bit tricky due to mutable borrowing rules
        while let Node::Reference(next) = &self.nodes[index.0] {
            index = *next;
        }
        match &mut self.nodes[index.0] {
            Node::Operation(operation) => operation,
            Node::Reference(_) => unreachable!(),
        }
    }
    pub fn into_ir(mut self) -> (Vec<ir::Node>, ir::TailEdge) {
        fn visit(
            index: NodeIndex,
            graph: &mut Graph,
            ir_nodes: &mut Vec<ir::Node>,
            context: &mut into_ir::Context,
        ) {
            if context.is_fully_visited(index) {
                return;
            }
            context.begin_visit(index);
            let operation = replace(graph.operation_mut(index), Operation::None {});
            operation.for_each_dependency(|&index| {
                visit(index, graph, ir_nodes, context);
            });
            let node_id = ir_nodes.len();
            ir_nodes.push(operation.convert(context).unwrap());
            context.finish_visit(index, node_id);
        }

        let mut ir_nodes = Vec::new();
        let mut context = into_ir::Context::new();

        let tail = replace(
            &mut self.tail,
            Tail::Return {
                return_values: Box::new([]),
            },
        );

        tail.for_each_dependency(|&index| {
            visit(index, &mut self, &mut ir_nodes, &mut context);
        });

        let ir_tail = tail.convert(&context).unwrap();
        (ir_nodes, ir_tail)
    }
}
